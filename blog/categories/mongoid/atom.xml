<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mongoid | Caner's Ruby on rails blog]]></title>
  <link href="http://canercak.github.io/blog/categories/mongoid/atom.xml" rel="self"/>
  <link href="http://canercak.github.io/"/>
  <updated>2014-07-21T01:12:24+03:00</updated>
  <id>http://canercak.github.io/</id>
  <author>
    <name><![CDATA[Caner Cakmak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Continuously Collecting User Facebook Data for Mongoid Application Using Omniauth]]></title>
    <link href="http://canercak.github.io/blog/2014/03/20/continuously-collecting-user-facebook-data-for-mongoid-application-using-omniauth/"/>
    <updated>2014-03-20T21:06:29+02:00</updated>
    <id>http://canercak.github.io/blog/2014/03/20/continuously-collecting-user-facebook-data-for-mongoid-application-using-omniauth</id>
    <content type="html"><![CDATA[<p>Data is the key to long-lasting relationship with users. The more, the better. Once we have relevant data; we can target marketing, develop features tailored to specific users and make users trust each other. So how do we collect relevant data? There is an easy way. It’s Facebook.</p>

<p>First, talk with your solicitor to add your Terms&amp;Conditions document that you are collecting data by using facebook. Then make a big “Login with Facebook” button on your landing page. Don’t forget to write that the user accepts the conditions once the button clicked. Something like this:</p>

<p><img class="<a" src="href="http://dl.dropbox.com/u/47336405/Selection_044.png">http://dl.dropbox.com/u/47336405/Selection_044.png</a>"></p>

<p> Then you are ready to go. I use three gems to collect data: omniauth, omniauth-facebook and koala. For config settings there is simple config and for caching data I use resque. I know that using devise could be easier. But simply, its big.(I have omniauth-identity for nonfacebook logins) So this will be different than devise’s way.</p>

<p>Here we define our facebook app details. Sensitive data is stored on local.rb file and Simpleconfig serves them to environments. Checkout simpleconfig for details.</p>

<p>``` ruby config/settings/application.rb</p>

<p>SimpleConfig.for :application do
  group :facebook do</p>

<pre><code>set :namespace, 'FACEBOOK_NAMESPACE'
set :app_id, 'FACEBOOK_APP_ID'
set :app_secret, 'FACEBOOK_SECRET'
set :scope, 'email, publish_stream, user_birthday, user_about_me, user_education_history, user_interests, user_likes, user_religion_politics, user_work_history'
set :cache_expiry_time, 7.days
</code></pre>

<p>  end</p>

<p>```</p>

<p>Here are omniauth initialization details. You can learn more about omniauth on it’s github page.</p>

<p>``` ruby config/initialisers/omniauth.rb</p>

<pre><code>OmniAuth.config.logger = Rails.logger
Rails.application.config.middleware.use OmniAuth::Builder do
  provider :facebook,
    APP_CONFIG.facebook.app_id,
    APP_CONFIG.facebook.app_secret,
    { scope: APP_CONFIG.facebook.scope }
end
</code></pre>

<p>```</p>

<p>``` ruby</p>

<pre><code>OmniAuth.config.logger = Rails.logger
Rails.application.config.middleware.use OmniAuth::Builder do
  provider :facebook,
    APP_CONFIG.facebook.app_id,
    APP_CONFIG.facebook.app_secret,
    { scope: APP_CONFIG.facebook.scope }
end
</code></pre>

<p>```</p>

<p>The haml view for our big facebook button.</p>

<p>``` haml  views/pages/_facebook_login.html.haml</p>

<pre><code>.hidden-phone
  = link_to auth_at_provider_path(provider: :facebook), class: 'btn btn-large btn-facebook', data: { :"no-turbolink" =&gt; true } do
    %i.icon-facebook-sign.icon-large
    = t('login_with_facebook')
%p.signin-terms
  %b= t('we_will_never_post')
  %br= t('pages.home.signin_terms', appname: APP_CONFIG.app_name, terms_link: link_to(t('terms'), :terms, :target=&gt; '_blank', data: { :"no-turbolink" =&gt; true }), policy_link: link_to(t('policy'), :policy, :target=&gt; '_blank')).html_safe
</code></pre>

<p>```</p>

<p>Necassary routes to manage sessions</p>

<p>``` ruby config/routes.rb
  # Sessions
  resources :sessions, only: [:create, :destroy]</p>

<p>  get &lsquo;auth/:provider&rsquo;, to: &lsquo;sessions#new&rsquo;, as: :auth_at_provider
  get &lsquo;auth/:provider/callback&rsquo;, to: &lsquo;sessions#create&rsquo;
  get &lsquo;auth/failure&rsquo;, to: redirect(&lsquo;/&rsquo;)
  get &lsquo;signout&rsquo;, to: &lsquo;sessions#destroy&rsquo;, as: :logout</p>

<p>```</p>

<p>Here is the user model. Removed the nonrelevant fields. As you can see I’m collecting enough data to make decisions.</p>

<p>``` ruby app/models/user.rb</p>

<pre><code>class User
  include Mongoid::Document
  include ::Concerns::User::Authentication
  include ::Concerns::User::Facebook

  field :provider
  field :uid
  field :oauth_token
  field :oauth_expires_at
  field :facebook_permissions, type: Array, default: []
  field :facebook_friends, type: Array, default: []
  field :facebook_favorites, type: Array, default: []
  field :facebook_data_cached_at, type: DateTime, default: '2014-01-01'
  field :gender
  field :username
  field :bio
  field :languages, type: Array, default: []
  field :birthday, type: Date
  field :work, type: Hash, default: {}
  field :education, type: Hash, default: {}
  field :email
  field :name
  field :facebook_verified, type: Boolean, default: false
</code></pre>

<p>```</p>

<p>Here is the module for facebook authentication. This will collect facebook user data before saving the user.</p>

<p>``` ruby app/models/concerns/authentication.rb</p>

<pre><code>module Concerns
  module User
    module Authentication
      extend ActiveSupport::Concern

      included do
        def set_fields_from_omniauth(auth)
          set_credentials auth.credentials
          set_info auth.info
          set_extra_raw_info auth.extra.raw_info
          set_extra_raw_info_special_permissions auth.extra.raw_info
          set_permissions
          Resque.enqueue(FacebookDataCacher, id)
        rescue Redis::CannotConnectError
        end

        private
        def set_credentials(credentials)
          self.oauth_token = credentials.token
          self.oauth_expires_at =  Time.at credentials.expires_at || Time.now
        end

        def set_info(info)
          self.email = info.email
          self.name = info.name
          self.facebook_verified = info.verified || false
        end
        def set_extra_raw_info(raw_info)
          self.username = raw_info.username
          self.gender = raw_info.gender
          self.bio = raw_info.bio
          self.languages = raw_info.languages || {}
        end
        def set_extra_raw_info_special_permissions(raw_info)
          self.birthday = Date.strptime(raw_info.birthday, "%m/%d/%Y").at_midnight if raw_info.birthday
          self.work = raw_info.work || {}
          self.education = raw_info.education || {}
        end
        def set_permissions
          facebook do |fb|
            self.facebook_permissions = fb.get_connections('me', 'permissions')[0]
          end
        end
      end

      module ClassMethods
        def from_omniauth(auth)
          user = where(auth.slice(:provider, :uid)).first_or_initialize
          user.provider = auth.provider
          user.uid = auth.uid
          user.set_fields_from_omniauth auth
          user.save!
          user
        end
      end
    end
  end
end
</code></pre>

<p>```</p>

<p>This module is for caching data. I’m making resque collect more and more details. We will run resque workers to get them. You can also schedule the process with resque scheduler. Checkout facebook graph api for more data to get. And checkout resque gem for details.</p>

<p>``` ruby app/models/concerns/facebook.rb</p>

<pre><code>module Concerns
  module User
    module Facebook
      extend ActiveSupport::Concern
      included do
        def facebook
          @facebook ||= Koala::Facebook::API.new(oauth_token)
          block_given? ? yield(@facebook) : @facebook
        rescue Koala::Facebook::APIError =&gt; e
          logger.info e.to_s
          nil
        end

        def has_facebook_permission?(scope)
           facebook_permissions[scope.to_s].to_i == 1 if facebook_permissions?
        end

        def cache_facebook_data?
          favorites = %w(music books movies television games activities interests)
          facebook do |fb|
            result = fb.batch do |batch_api|
              batch_api.get_connections('me', 'friends')
              favorites.each do |favorite|
                batch_api.get_connections('me', favorite)
              end
            end
            if result.any?
               self.facebook_friends = result[0] ? result[0] : []
              self.facebook_favorites = result[1] ? result[1..-1].flatten : []
              return true
            end
          end
          false
        end
      end

      module ClassMethods
      end
    end
  end
end
</code></pre>

<p>```</p>

<p>We define a resque worker to cache facebook data.</p>

<p>``` ruby app/workers/facebook_data_cacher.rb</p>

<pre><code>class FacebookDataCacher
  @queue = :facebook_cache_data_queue
  def self.perform(user_id)
    user = User.find user_id
    if user.facebook_data_cached_at &lt; APP_CONFIG.facebook.cache_expiry_time.ago.utc
      if user.cache_facebook_data?
        user.update_attribute :facebook_data_cached_at, Time.now.utc
      end
    end
  end
end
</code></pre>

<p>```</p>

<p>Here we go. The code above will get us the data we defined on our model and it will be updating and adding more data when user logins. Now it’s time to make decisions!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Full Login System Out of Omniauth-identity With Mongoid and Jquery Validations]]></title>
    <link href="http://canercak.github.io/blog/2014/02/09/full-login-system-out-of-omniauth-identity-with-mongoid-and-jquery-validations/"/>
    <updated>2014-02-09T11:31:32+02:00</updated>
    <id>http://canercak.github.io/blog/2014/02/09/full-login-system-out-of-omniauth-identity-with-mongoid-and-jquery-validations</id>
    <content type="html"><![CDATA[<p>I want to start this post with one definite sentence. Don’t use omniauth-identity! Why? Because it doesn’t cover the “details” of a login system. And for a login system details are absolutely necesssary. It does make the user register and sign-in but thats all. No forms, no password resets, no emails, no decent validations, etc. It’s really simple and that simplicity won’t help you. And the worst thing is it’s hard to customise. You have that initialiser file and you don’t understand what you do in there. There are also no resources other than Ryan’s Railscast and couple of blog posts. The reason I’m writing this blog post is because there may be people still wan’t to use it as I do. I’ve lost considerable amount of time dealing with it’s login fail bug, integrating it and making a decent login system out of it and now after all that time I don’t want to deal with login systems at all.</p>

<p>So we start with adding the gem</p>

<p>``` ruby Gemfile</p>

<pre><code>gem "omniauth"
gem 'omniauth-identity'
And we have this initialiser file also used in other omniauth providers. That line fixes the bug..
</code></pre>

<p>```</p>

<p>``` ruby config/initialisers/omniauth.rb</p>

<pre><code>OmniAuth.config.on_failure = Proc.new { |env|
  OmniAuth::FailureEndpoint.new(env).redirect_to_failure
}
end
</code></pre>

<p>```
Then we create the modal and yes it doesn’t directly integrate with your user model(or I didn’t lost time trying to do it). You will have a seperate mongoid collection and it will store identities</p>

<p>``` ruby models/identity.rb</p>

<pre><code>class Identity
  include Mongoid::Document
  include OmniAuth::Identity::Models::Mongoid

  field :email, type: String
  field :name, type: String
  field :password_digest, type: String
  field :username, type: String

  belongs_to :user
  validates_presence_of :name
  validate :uniqueness_of_email
  validates_format_of :email, :with =&gt; /^[-a-z0-9_+\.]+\@([-a-z0-9]+\.)+[a-z0-9]{2,4}$/i


  def uniqueness_of_email
    self.errors.add(:email, "email is already in use") unless User.find_by(email:email).nil?
  end

end
</code></pre>

<p>```</p>

<p>I have authentication file in models directory that also manages omniauth facebook so after saving the identity don’t forget to save the user too. I’m setting user’s provider as “identity”, since I only get name and email I had to set uid as username.</p>

<p>``` ruby models/concerns/user/authentication.rb</p>

<p>  def from_omniauth(auth)</p>

<pre><code>binding.pry

user = where(auth.slice(:provider, :uid)).first_or_initialize
return nil if user.new_record? &amp;&amp; !user.has_access?
  user.provider = auth.provider
  user.uid = auth.uid
  user.email = auth.email
  user.username = auth.uid
  user.set_fields_from_omniauth auth
  user.login_count = user.login_count+ 1
  user.save!
if user.login_count == 1
  UserMailer.welcome_email(self.first).deliver
end
user 
</code></pre>

<p>  end
```</p>

<p>Controller only has new method. Taken from Ryan’s railcast.</p>

<p>``` ruby controllers/identities_controller.rb
 class IdentitiesController &lt; ApplicationController</p>

<pre><code>def new
  @identity = env['omniauth.identity']
  @user =User.new
end
</code></pre>

<p>```</p>

<p>sessions controller as usual</p>

<p>``` ruby controllers/sessions_controller.rb</p>

<pre><code>class SessionsController &lt; ApplicationController

  skip_before_filter :require_login, except: [:destroy]

  def create
    if (user = User.from_omniauth env['omniauth.auth'])
      session[:user_id] = user.id.to_s
      redirect_to session.delete(:redirect_to) || new_quote_path
    else
      redirect_to root_path, flash: { error: t(APP_CONFIG.facebook.restricted_group_id ? 'flash.sessions.error.restricted' : 'flash.sessions.error.create') }
    end
  end

  def destroy
    session[:user_id] = nil
    redirect_to root_path
  end
  def failure

    redirect_to root_path, flash: { error: t(APP_CONFIG.facebook.restricted_group_id ? 'flash.sessions.error.restricted' : 'flash.sessions.error.create') }
  end
end
</code></pre>

<p>```</p>

<p>I use modals to show forms</p>

<p>``` haml views/pages/home.html.haml
  %big.inline-block.new-identity= link_to t(&lsquo;register_now&rsquo;), &lsquo;#new-identity&rsquo;, data: { toggle: &lsquo;modal&rsquo; }
  %big.inline-block.new-identity veya
  %big.inline-block.login-identity= link_to t(&lsquo;login_now&rsquo;), &lsquo;#login-identity&rsquo;, data: { toggle: &lsquo;modal&rsquo; }</p>

<p><code>
</code> haml views/shared/_modal_login_identity.html.haml</p>

<pre><code>#login-identity.modal.hide.fade{ tabindex: -1, role: 'dialog', 'aria-labelledby' =&gt; t('login_identity'), 'aria-hidden' =&gt; true }
  .modal-header
    %button.close{ type: 'button', data: { dismiss: 'modal' }, 'aria-hidden' =&gt; true } &amp;times;
    %h3= t('shared.navbar.login_identity')
  .modal-body
    = render 'identities/login'
  .modal-footer
    = link_to t('close'), '#', 'aria-hidden' =&gt; true, data: { dismiss: 'modal' }, class: 'btn'
</code></pre>

<p><code>
</code> haml views/shared/_modal_new_identity.html.haml</p>

<pre><code>#new-identity.modal.hide.fade{ tabindex: -1, role: 'dialog', 'aria-labelledby' =&gt; t('new_identity'), 'aria-hidden' =&gt; true }
  .modal-header
    %button.close{ type: 'button', data: { dismiss: 'modal' }, 'aria-hidden' =&gt; true } &amp;times;
    %h3= t('shared.navbar.new_identity')
  .modal-body
    =render 'identities/register'
  .modal-footer
    = link_to t('close'), '#', 'aria-hidden' =&gt; true, data: { dismiss: 'modal' }, class: 'btn'
</code></pre>

<p><code>
</code> ruby views/identities/_login.html.haml</p>

<pre><code>=form_tag('/auth/identity/callback',  :method =&gt; 'post', :id =&gt; 'actual-login-form') do
  = label_tag :login_error, t("shared.navbar.wrong_password"), class: 'control-label', id: 'error_code_label_login'
  .field
    = label_tag :auth_key,t('shared.navbar.email')
    = text_field_tag :auth_key, nil
  .field
    = label_tag :password, t('shared.navbar.password')
    = password_field_tag :password, nil
  .actions
    = submit_tag t('shared.navbar.login'), id: "login_submit", class: 'btn btn-primary', disable_with: t('helpers.disable_with')
  %br
    = link_to t('shared.navbar.forgot_password'), new_password_reset_path
- if flash[:error] == I18n.t("shared.navbar.wrong_password")
  :coffee
    $(document).on 'ready', -&gt;
      $("#login-identity").modal "show"
      $("#error_code_label_login").show()
      $("#password").focus()
</code></pre>

<p><code>
</code> ruby views/identities/_register.rb</p>

<pre><code>= form_tag "/auth/identity/register", id: 'signupForm' do
  - if @identity &amp;&amp; @identity.errors.any?
    .error_messages
      %h2
        = pluralize(@identity.errors.count, "error")
        prohibited this account from being saved:
      %ul
        - @identity.errors.full_messages.each do |msg|
          %li= msg
  .field
    = label_tag :name, t('shared.navbar.name')
    = text_field_tag :name, @identity.try(:name)
  .field
    = label_tag :email,t('shared.navbar.email')
    = text_field_tag :email, @identity.try(:email)
  .field
    = label_tag :password, t('shared.navbar.password')
    = password_field_tag :password
  .field
    = label_tag :password_confirmation,t('shared.navbar.password_again')
    = password_field_tag :password_confirmation
  = submit_tag t('shared.navbar.register'), class: 'btn btn-primary', disable_with: t('helpers.disable_with')
</code></pre>

<p>```
I use jquery validation which I love</p>

<p>``` coffeescript pages.js.coffee</p>

<pre><code>$(document).on 'ready', -&gt;

  $("#signupForm").validate
    errorClass: "error_class"
    validClass: "valid_class"
    rules:
      name: 
        required: true
      email:
        required: true
        email: true
        remote: "/users/check_email"
      password:
        required: true
        minlength: 5
      password_confirmation:
        required: true
        minlength: 5
        equalTo: "#password"
    messages:
      name: I18n.t "signup.name.required"
      password:
        required: I18n.t "signup.name"
        minlength: I18n.t "signup.password.minlength"
      password_confirmation:
        required: I18n.t "signup.password_confirmation.required"
        minlength: I18n.t "signup.password_confirmation.minlength"
        equalTo: I18n.t "signup.password_confirmation.equalTo"
      email:
        required: I18n.t "signup.email.required"
        email: I18n.t "signup.email.email"
        remote: I18n.t "signup.email.remote"

  $("#actual-login-form").validate
    errorClass: "error_class"
    validClass: "valid_class"
    rules:
      email:
        required: true
        email: true
      password:
        required: true
    messages:
      password:
        required: I18n.t "signup.name"
      email:
        required: I18n.t "signup.email.required"
        email: I18n.t "signup.email.email"
</code></pre>

<p><code>
</code> ruby controllers/users_controller/check_email.rb
  def check_email</p>

<pre><code>@user = User.find_by(email: params[:email])
respond_to do |format|
 format.json { render :json =&gt; !@user }
end
</code></pre>

<p>  end</p>

<p>```
My password reset codes</p>

<p>``` ruby controllers/password_resets_controller.rb</p>

<pre><code>class PasswordResetsController &lt; ApplicationController
  def new
  end

  def create
    user = User.find_by(email: params[:email])
    user.send_password_reset(user)
    redirect_to root_url, :notice =&gt; I18n.t("password_resets.email_sent")
  end

  def edit
    @user = User.find_by(password_reset_token: params[:id])
  end

  def update
    @user = User.find_by(password_reset_token: params[:id])
    if @user.password_reset_sent_at &lt; 2.hours.ago
      redirect_to new_password_reset_path, :alert =&gt; I18n.t("password_resets.expired")
    else
      @user.update_attributes(permitted_params.user)
      @identity = Identity.find_by email: @user.email
      @identity.password = @user.password
      @identity.password_confirmation = @user.password_confirmation
      if @identity.save
        redirect_to root_url, :notice =&gt; I18n.t("password_resets.password_has_been_reset")
      else
        redirect_to root_url, :notice =&gt; I18n.t("password_resets.error_in_password_reset")
      end
    end
  end
end
</code></pre>

<p><code>
</code> haml views/password_resets/new.html.haml</p>

<pre><code>= form_tag password_resets_path, :method =&gt; :post do
  .field
    = label_tag :email, t('shared.navbar.email')
    = text_field_tag :email, params[:email]
  = submit_tag t('shared.navbar.reset_password'),  class: 'btn btn-primary', disable_with: t('helpers.disable_with')
</code></pre>

<p><code>
</code> haml views/password_resets/edit.html.haml</p>

<pre><code>= form_for @user, :url =&gt; password_reset_path(params[:id]) do |f|
  - if @user.errors.any?
    .error_messages
      %h2 Form is invalid
      %ul
        - for message in @user.errors.full_messages
          %li= message
  .field
    = f.label :password
    = f.password_field :password
  .field
    = f.label :password_confirmation
    = f.password_field :password_confirmation
  .actions= f.submit "Update Password"
</code></pre>

<p>```
Mailers</p>

<p>``` ruby app/mailers/password_resets_mailer.rb
  def password_reset_email(user)</p>

<pre><code>@user = user
binding.pry
mail(to: user["email"], subject: t('user_mailer.pass_reset.subject'))
</code></pre>

<p>  end
```</p>

<p>and the actual mail which I’ve only paste the relevant part</p>

<p>``` haml app/views/mailers/password_reset.html.haml</p>

<pre><code>#href: "#{edit_password_reset_url(@user.password_reset_token)}"}=t(".pass_reset_link_button")
</code></pre>

<p>```
So it works. At least omniauth-identity has tests..I really could not do test-driven with it so I’ll add the tests soon..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating Activity Cal-heatmap Using Public_activity and Mongoid]]></title>
    <link href="http://canercak.github.io/blog/2013/08/02/creating-activity-cal-heatmap-using-public-activity-and-mongoid/"/>
    <updated>2013-08-02T12:11:21+03:00</updated>
    <id>http://canercak.github.io/blog/2013/08/02/creating-activity-cal-heatmap-using-public-activity-and-mongoid</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="http://dl.dropbox.com/u/47336405/Selection_043.png">http://dl.dropbox.com/u/47336405/Selection_043.png</a>"></p>

<p>I had to present activites of a service provider to it’s users in a unique way. First thought of creating an activity stream but knew that the users won’t be reading them since the activity would be about the services of the provider- not something “social”. Then thought of creating a line graph that shows the days and works done by the provider. It wouldn’t be unique though. I thought and thought by looking at my github dashboard and idea came up. I always liked Github’s collaboration heatmap. It was unique and concise. So I decided to create my own activity heatmap.
I needed to sort out three things in order to make it happen.
Finding out a github-like heatmap to present activities Logging provider activites in a way that I can present on map Making mongoid and Rails 4 work with heatmap and activity logs.
Here is how I created my activity heatmap:
Kamisama has done great job on creating cal-heatmaps. Its obvious that github uses his work too. You can find his work on <a href="https://github.com/kamisama/cal-heatmap.">https://github.com/kamisama/cal-heatmap.</a> You have to download cal-heatmap.js, d3.js and for localisation; moment.js does great job. I had to present three activites to user;
When provider gets selected by user. When provider returns to quote When provider does the work
You cannot divide the activities to parts in cal-heatmap. You provide timestamps with numeric values and cal-heatmap shows the data. So I first had to fetch these three activities, count them and show them on map. Then I would present the details once the user clicks on a cell. So “get_provider_counts” counts the data in a way cal-heatmap understands, “get_activity gets” the data once I click on a cell.</p>

<p>``` coffeescript providers.js.coffee</p>

<pre><code>initProviderShow = -&gt;
  $.ajax(
    url: "/activities/get_provider_counts"
    type: "GET"
    data:
      id: $("#provider_id").val()
    dataType: "json"
    ).success (data) -&gt;
    moment.lang "en"
    calendar = new CalHeatMap()
    calendar.init
      itemSelector: "#calheat"
      data: data
      start: new Date(2014, 1)
      domain: "month"
      subDomain: "day"
      range: 7
      cellSize: 15
      cellPadding: 5
      domainGutter: 20
      displayScale: false
      previousSelector: "#calheat-PreviousDomain-selector"
      nextSelector: "#calheat-NextDomain-selector"
      domainLabelFormat: (date) -&gt;
        moment(date).format("MMMM")
      subDomainDateFormat: (date) -&gt;
        moment(date).format "LL"
      subDomainTitleFormat:
        empty: "{date} +I18n.t "shared.navbar.no_activites"
        filled: "{date}  {count} +I18n.t "shared.navbar.has_activites"
      onClick: (date) -&gt;
        $.ajax
          type: "GET"
          url: "/activities/get_activity"
          data: { id: $("#provider_id").val(), selected: date}
          success: (data) -&gt;
            text1= ""
            text2 =""
            text3 = ""
            if data.selected &gt; 0
              text1 = data.selected + " " +I18n.t "shared.navbar.selected
            if data.returned &gt; 0
              text2 = data.returned + " " +I18n.t "shared.navbar.returned
            if data.done &gt; 0
              text3 = data.done + " " + I18n.t "shared.navbar.done"
            if text1.length &gt; 0 || text2.length &gt; 0 || text3.length &gt; 0
              $("#onClick-placeholder").html text1 + "&lt;br/&gt;" + text2 + "&lt;br/&gt;" + text3
              $("#onClick-placeholder").show()
            else
              $("#onClick-placeholder").html ""
              $("#onClick-placeholder").hide()
          error: (data) -&gt;
              return
        return
      legend: [
        1
        3
        5
      ]
      legendColors: [
        "#ecf5e2"
        "#232181"
      ]
  return
</code></pre>

<p>```</p>

<p>I was about to store provider activities myself but then found a great gem to sort it out. Its public_activity gem. <a href="https://github.com/pokonski/public_activity">https://github.com/pokonski/public_activity</a> It’s quote comprehensve and does support mongoid and Rails 4.
The system I’m working on is about User creating quotes to providers. For every quote user selects up to three providers. Provider “returns” back to quote and if agrees with user, provider “does” the work. So I’m tracking the user, relation to providers collection, returned providers and providerdone.</p>

<p>``` ruby Quote.rb</p>

<pre><code>require 'autoinc'
class Quote
  include Mongoid::Document
  include Mongoid::Timestamps
  include Mongoid::Paranoia
  include Mongoid::Slug
  include Mongoid::Autoinc
  include Geocoder::Model::Mongoid
  include Concerns::GmapRoute
  include PublicActivity::Model
  tracked :owner =&gt; :user
  tracked :params =&gt; {
      :returned_providers =&gt; :returned_providers,
      :providerdone =&gt; :providerdone,
      :providers =&gt; :provider_ids
  }
</code></pre>

<p>```</p>

<p>I created a controller to store activities. Our system does not have activity streams so this will be useful for new features too. These two methods are for ajax requests I explained above.</p>

<p>``` ruby activities_controller.rb</p>

<pre><code>def get_provider_counts
    @provider = Provider.find(params[:id])
    @activities = PublicActivity::Activity.all
    selected_providers =@activities.where("parameters.providers"=&gt;@provider._id,"key"=&gt;"quote.create").group_by {|d| d.created_at.to_i}
    returned_providers =@activities.where("parameters.returned_providers"=&gt;"#{@provider._id}","key"=&gt;"quote.update").group_by {|d| d.created_at.to_i}
    done_providers =@activities.where("parameters.providerdone"=&gt;"#{@provider._id}","key"=&gt;"quote.update").group_by {|d| d.created_at.to_i}
    @caldata = {}
    seldata = {}
    retdata ={}
    donedata = {}
    selected_providers.each do |provider|
      seldata = {"#{provider[0]}" =&gt; provider[1].count}
    end
    returned_providers.each do |provider|
      retdata = {"#{provider[0]}" =&gt; provider[1].count}
    end
    done_providers.each do |provider|
      donedata = {"#{provider[0]}" =&gt; provider[1].count}
    end
    @caldata = donedata.merge(retdata) {|key, oldval, newval| newval + oldval}
    @caldata = @caldata.merge(seldata) {|key, oldval, newval| newval + oldval}
    respond_to do |format|
      format.json  { render :json =&gt; @caldata.to_json}
    end
  end

  def get_activity
    @provider = Provider.find(params[:id])
    date = Date.parse(params[:selected])
    @activities = PublicActivity::Activity.all
    selected_providers =@activities.where("parameters.providers"=&gt;@provider._id,:created_at=&gt;date.beginning_of_day..date.end_of_day, "key"=&gt;"quote.create")
    returned_providers =@activities.where("parameters.returned_providers"=&gt;"#{@provider._id}",:created_at=&gt;date.beginning_of_day..date.end_of_day,"key"=&gt;"quote.update")
    done_providers =@activities.where("parameters.providerdone"=&gt;"#{@provider._id}",:created_at=&gt;date.beginning_of_day..date.end_of_day,"key"=&gt;"quote.update")
    respond_to do |format|
      format.json  { render :json =&gt; {:selected=&gt; selected_providers.count,:returned =&gt;returned_providers.count,:done=&gt;done_providers.count}}
    end
  end
</code></pre>

<p>```</p>

<p>Finally the view to show cal-heatmap</p>

<p>``` haml providers/show.html.haml</p>

<pre><code>%div
  #calheat{style: "position:relative;"}
  %p
  %button#calheat-PreviousDomain-selector.btn.btn-mini
    %i.icon.icon-chevron-left
  %button#calheat-NextDomain-selector.btn.btn-mini
    %i.icon.icon-chevron-right
  %h5{style:"text-align: center;margin-top: -10px;"}
  #onClick-placeholder
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Factor Authentication Using Active_model_otp With Mongoid]]></title>
    <link href="http://canercak.github.io/blog/2011/06/03/two-factor-authentication-using-active-model-otp-with-mongoid/"/>
    <updated>2011-06-03T17:13:26+03:00</updated>
    <id>http://canercak.github.io/blog/2011/06/03/two-factor-authentication-using-active-model-otp-with-mongoid</id>
    <content type="html"><![CDATA[<p>I had to implement two factor authentication using a custom sms provider. Active model OTP really helped me in generating one time use tokens. I thought it won’t be working with mongoid but it was easy to integrate it. Another issue was to make user authenticated on the same page. We just didn’t want to direct user to another page for phone verification. So I’ve written some js to sort it out. It’s a bit “manual” because clientsidevalidations caused problems in Rails4. Everything gets validated both on client and server side. Here you can see relevant parts from the code.</p>

<p>``` ruby provider.rb</p>

<pre><code>def check_verification_code
data = {:result =&gt; false}
if current_user.authenticate_otp(params[:verification_code], drift: 200) #drift enough for old users 
  data = {:result =&gt; true}
  session[:mobile_verified] = true
end
respond_to do |format|
  format.json  { render :json =&gt; data} 
end
</code></pre>

<p>  end</p>

<p>  def sendverification</p>

<pre><code>data = {:result =&gt; false} 
phone = validate_phone(params[:verification_phone])
if phone.present?
  sms = Sms.new       
  if sms.send_sms([phone],APP_CONFIG.sms_from, t('verification_message') + current_user.otp_code.to_s)
    data = {:result =&gt; true} 
  end
end
respond_to do |format|
  format.json  { render :json =&gt; data} 
end
</code></pre>

<p>  end</p>

<p>```</p>

<p>``` haml new.html.haml</p>

<pre><code>= bootstrap_form_for @provider, id: @provider.id,  validate: true  do |f|
    .span{style: 'text-align: center'} 
      %h4= t('.provider_exp')
      %h5= t('.provider_exp1')
      #phone_details
        = f.label :mobile_phone, class: 'control-label', id: 'verify_phone_label'
        = f.default_tag :text_field, :verification_phone, placeholder: '05XX XXXXXXX', id: 'verification_phone' ,:class =&gt; "{mask:'(0569) 9999999'}", :alt=&gt; "(0569) 9999999'"     
        = button_to t('.send_code'), "#", :id=&gt; 'sendverification', :class=&gt; 'btn btn-medium btn-success'
        = f.label :error_mobile_label, class: 'control-label', id: 'error_mobile_label' 
      %hr
      #verification_details
        = f.label :info_label, class: 'control-label', id: 'verify_code_label' , style:"display:none"
        = f.default_tag :text_field, :verification_code, placeholder: 'XXXXXX', id: 'verification_code' ,:class =&gt; "{mask:'999999'}", :alt=&gt; "999999'" 
        = f.label :error_label, class: 'control-label', id: 'error_code_label' 
        = f.label :success_label, class: 'control-label', id: 'success_code_label' 
</code></pre>

<p><code>
</code> coffeescript providers.js.coffee</p>

<p>  $(&ldquo;#verification_code&rdquo;).bind &ldquo;keyup&rdquo;, &ndash;></p>

<pre><code>  if $(this).val().length is 6 #second clientside validation
    data = undefined
    $.ajax
      type: "POST"
      url: "/check_verification_code"
      data: "verification_code=" + $("#verification_code").val() 
      success: (data) -&gt;
        if data.result is true
          $("#provider_business_phone").val($("#verification_phone").val())
          clearInterval(interval)
          $("#error_code_label").hide()
          $("#success_code_label").show()            
          $("#verification_code").prop "disabled", true
          $("#provider_submit").prop "value", I18n.t "shared.navbar.pleasewait"            
          $("#providerform").submit() # provider gets mobile_verified inside
          return
        else
          $("#error_code_label").text I18n.t('shared.navbar.error_in_code').show()
        return
      error: (data) -&gt;
          $("#error_code_label").text  I18n.t('shared.navbar.problem_sending_request').show()  
          return
  else
    $("#error_code_label").hide()
    $("#success_code_label").hide()
    return
  return 

interval = undefined
$("#sendverification").click -&gt;
  if $("#verification_phone").val().length is 14 #second clientside vald(before svrside)
    time = 30000 #OTP default wait time
    seconds = Math.ceil(time / 1000)
    $(this).each -&gt;
      disabled_elem = $(this)
      $("#verification_phone").prop "disabled", true
      disabled_elem.prop "disabled", true 
      new_text =  I18n.t('shared.navbar.send_code_again') 
      disabled_elem.val new_text + " (" + seconds + ")"
      interval = setInterval(-&gt;
        disabled_elem.val new_text + " (" + --seconds + ")"
        if seconds is 0
          $("#verification_phone").prop "disabled", false
          disabled_elem.prop "disabled", false
          disabled_elem.val new_text
          clearInterval interval
        return
      , 1000)
      return
    $.ajax
      data: "verification_phone=" + $("#verification_phone").val()
      type: "get"
      url: "/sendverification"
      success: (data) -&gt;
        if data.result is true
          $("#verification_code").show()
          $("#verify_code_label").show()
          $("#error_mobile_label").hide()  
          $("#error_code_label").hide()
          $("#verification_code").val ''
          $("#verification_code").focus() 
          return
        else
          $("#error_mobile_label").text I18n.t('shared.navbar.problem_sending_sms').show() 
          return
      error: (data) -&gt;
          $("#error_mobile_label").text  I18n.t('shared.navbar.problem_sending_request').show()  
          return
  return false 
</code></pre>

<p>```</p>

<p>``` ruby providers_controller.rb
  def create</p>

<pre><code>...
if session[:mobile_verified] = true
  @provider.mobile_verified = true
  @provider.business_phone = validate_phone( params[:provider][:business_phone])
  session[:mobile_verified] = false
else
...
</code></pre>

<p>```</p>

<p>``` ruby user.rb
  require &ldquo;active_model_otp&rdquo;
  class User</p>

<pre><code>include Mongoid::Document
...
include ActiveModel::OneTimePassword 
...
has_one_time_password
...
field :email
field :otp_secret_key 
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
