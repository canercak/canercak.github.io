<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Two Factor Authentication | Caner's Ruby on rails blog]]></title>
  <link href="http://canercak.github.io/blog/categories/two-factor-authentication/atom.xml" rel="self"/>
  <link href="http://canercak.github.io/"/>
  <updated>2014-07-21T01:12:24+03:00</updated>
  <id>http://canercak.github.io/</id>
  <author>
    <name><![CDATA[Caner Cakmak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Creating Activity Cal-heatmap Using Public_activity and Mongoid]]></title>
    <link href="http://canercak.github.io/blog/2013/08/02/creating-activity-cal-heatmap-using-public-activity-and-mongoid/"/>
    <updated>2013-08-02T12:11:21+03:00</updated>
    <id>http://canercak.github.io/blog/2013/08/02/creating-activity-cal-heatmap-using-public-activity-and-mongoid</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="http://dl.dropbox.com/u/47336405/Selection_043.png">http://dl.dropbox.com/u/47336405/Selection_043.png</a>"></p>

<p>I had to present activites of a service provider to it’s users in a unique way. First thought of creating an activity stream but knew that the users won’t be reading them since the activity would be about the services of the provider- not something “social”. Then thought of creating a line graph that shows the days and works done by the provider. It wouldn’t be unique though. I thought and thought by looking at my github dashboard and idea came up. I always liked Github’s collaboration heatmap. It was unique and concise. So I decided to create my own activity heatmap.
I needed to sort out three things in order to make it happen.
Finding out a github-like heatmap to present activities Logging provider activites in a way that I can present on map Making mongoid and Rails 4 work with heatmap and activity logs.
Here is how I created my activity heatmap:
Kamisama has done great job on creating cal-heatmaps. Its obvious that github uses his work too. You can find his work on <a href="https://github.com/kamisama/cal-heatmap.">https://github.com/kamisama/cal-heatmap.</a> You have to download cal-heatmap.js, d3.js and for localisation; moment.js does great job. I had to present three activites to user;
When provider gets selected by user. When provider returns to quote When provider does the work
You cannot divide the activities to parts in cal-heatmap. You provide timestamps with numeric values and cal-heatmap shows the data. So I first had to fetch these three activities, count them and show them on map. Then I would present the details once the user clicks on a cell. So “get_provider_counts” counts the data in a way cal-heatmap understands, “get_activity gets” the data once I click on a cell.</p>

<p>``` coffeescript providers.js.coffee</p>

<pre><code>initProviderShow = -&gt;
  $.ajax(
    url: "/activities/get_provider_counts"
    type: "GET"
    data:
      id: $("#provider_id").val()
    dataType: "json"
    ).success (data) -&gt;
    moment.lang "en"
    calendar = new CalHeatMap()
    calendar.init
      itemSelector: "#calheat"
      data: data
      start: new Date(2014, 1)
      domain: "month"
      subDomain: "day"
      range: 7
      cellSize: 15
      cellPadding: 5
      domainGutter: 20
      displayScale: false
      previousSelector: "#calheat-PreviousDomain-selector"
      nextSelector: "#calheat-NextDomain-selector"
      domainLabelFormat: (date) -&gt;
        moment(date).format("MMMM")
      subDomainDateFormat: (date) -&gt;
        moment(date).format "LL"
      subDomainTitleFormat:
        empty: "{date} +I18n.t "shared.navbar.no_activites"
        filled: "{date}  {count} +I18n.t "shared.navbar.has_activites"
      onClick: (date) -&gt;
        $.ajax
          type: "GET"
          url: "/activities/get_activity"
          data: { id: $("#provider_id").val(), selected: date}
          success: (data) -&gt;
            text1= ""
            text2 =""
            text3 = ""
            if data.selected &gt; 0
              text1 = data.selected + " " +I18n.t "shared.navbar.selected
            if data.returned &gt; 0
              text2 = data.returned + " " +I18n.t "shared.navbar.returned
            if data.done &gt; 0
              text3 = data.done + " " + I18n.t "shared.navbar.done"
            if text1.length &gt; 0 || text2.length &gt; 0 || text3.length &gt; 0
              $("#onClick-placeholder").html text1 + "&lt;br/&gt;" + text2 + "&lt;br/&gt;" + text3
              $("#onClick-placeholder").show()
            else
              $("#onClick-placeholder").html ""
              $("#onClick-placeholder").hide()
          error: (data) -&gt;
              return
        return
      legend: [
        1
        3
        5
      ]
      legendColors: [
        "#ecf5e2"
        "#232181"
      ]
  return
</code></pre>

<p>```</p>

<p>I was about to store provider activities myself but then found a great gem to sort it out. Its public_activity gem. <a href="https://github.com/pokonski/public_activity">https://github.com/pokonski/public_activity</a> It’s quote comprehensve and does support mongoid and Rails 4.
The system I’m working on is about User creating quotes to providers. For every quote user selects up to three providers. Provider “returns” back to quote and if agrees with user, provider “does” the work. So I’m tracking the user, relation to providers collection, returned providers and providerdone.</p>

<p>``` ruby Quote.rb</p>

<pre><code>require 'autoinc'
class Quote
  include Mongoid::Document
  include Mongoid::Timestamps
  include Mongoid::Paranoia
  include Mongoid::Slug
  include Mongoid::Autoinc
  include Geocoder::Model::Mongoid
  include Concerns::GmapRoute
  include PublicActivity::Model
  tracked :owner =&gt; :user
  tracked :params =&gt; {
      :returned_providers =&gt; :returned_providers,
      :providerdone =&gt; :providerdone,
      :providers =&gt; :provider_ids
  }
</code></pre>

<p>```</p>

<p>I created a controller to store activities. Our system does not have activity streams so this will be useful for new features too. These two methods are for ajax requests I explained above.</p>

<p>``` ruby activities_controller.rb</p>

<pre><code>def get_provider_counts
    @provider = Provider.find(params[:id])
    @activities = PublicActivity::Activity.all
    selected_providers =@activities.where("parameters.providers"=&gt;@provider._id,"key"=&gt;"quote.create").group_by {|d| d.created_at.to_i}
    returned_providers =@activities.where("parameters.returned_providers"=&gt;"#{@provider._id}","key"=&gt;"quote.update").group_by {|d| d.created_at.to_i}
    done_providers =@activities.where("parameters.providerdone"=&gt;"#{@provider._id}","key"=&gt;"quote.update").group_by {|d| d.created_at.to_i}
    @caldata = {}
    seldata = {}
    retdata ={}
    donedata = {}
    selected_providers.each do |provider|
      seldata = {"#{provider[0]}" =&gt; provider[1].count}
    end
    returned_providers.each do |provider|
      retdata = {"#{provider[0]}" =&gt; provider[1].count}
    end
    done_providers.each do |provider|
      donedata = {"#{provider[0]}" =&gt; provider[1].count}
    end
    @caldata = donedata.merge(retdata) {|key, oldval, newval| newval + oldval}
    @caldata = @caldata.merge(seldata) {|key, oldval, newval| newval + oldval}
    respond_to do |format|
      format.json  { render :json =&gt; @caldata.to_json}
    end
  end

  def get_activity
    @provider = Provider.find(params[:id])
    date = Date.parse(params[:selected])
    @activities = PublicActivity::Activity.all
    selected_providers =@activities.where("parameters.providers"=&gt;@provider._id,:created_at=&gt;date.beginning_of_day..date.end_of_day, "key"=&gt;"quote.create")
    returned_providers =@activities.where("parameters.returned_providers"=&gt;"#{@provider._id}",:created_at=&gt;date.beginning_of_day..date.end_of_day,"key"=&gt;"quote.update")
    done_providers =@activities.where("parameters.providerdone"=&gt;"#{@provider._id}",:created_at=&gt;date.beginning_of_day..date.end_of_day,"key"=&gt;"quote.update")
    respond_to do |format|
      format.json  { render :json =&gt; {:selected=&gt; selected_providers.count,:returned =&gt;returned_providers.count,:done=&gt;done_providers.count}}
    end
  end
</code></pre>

<p>```</p>

<p>Finally the view to show cal-heatmap</p>

<p>``` haml providers/show.html.haml</p>

<pre><code>%div
  #calheat{style: "position:relative;"}
  %p
  %button#calheat-PreviousDomain-selector.btn.btn-mini
    %i.icon.icon-chevron-left
  %button#calheat-NextDomain-selector.btn.btn-mini
    %i.icon.icon-chevron-right
  %h5{style:"text-align: center;margin-top: -10px;"}
  #onClick-placeholder
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Factor Authentication Using Active_model_otp With Mongoid]]></title>
    <link href="http://canercak.github.io/blog/2011/06/03/two-factor-authentication-using-active-model-otp-with-mongoid/"/>
    <updated>2011-06-03T17:13:26+03:00</updated>
    <id>http://canercak.github.io/blog/2011/06/03/two-factor-authentication-using-active-model-otp-with-mongoid</id>
    <content type="html"><![CDATA[<p>I had to implement two factor authentication using a custom sms provider. Active model OTP really helped me in generating one time use tokens. I thought it won’t be working with mongoid but it was easy to integrate it. Another issue was to make user authenticated on the same page. We just didn’t want to direct user to another page for phone verification. So I’ve written some js to sort it out. It’s a bit “manual” because clientsidevalidations caused problems in Rails4. Everything gets validated both on client and server side. Here you can see relevant parts from the code.</p>

<p>``` ruby provider.rb</p>

<pre><code>def check_verification_code
data = {:result =&gt; false}
if current_user.authenticate_otp(params[:verification_code], drift: 200) #drift enough for old users 
  data = {:result =&gt; true}
  session[:mobile_verified] = true
end
respond_to do |format|
  format.json  { render :json =&gt; data} 
end
</code></pre>

<p>  end</p>

<p>  def sendverification</p>

<pre><code>data = {:result =&gt; false} 
phone = validate_phone(params[:verification_phone])
if phone.present?
  sms = Sms.new       
  if sms.send_sms([phone],APP_CONFIG.sms_from, t('verification_message') + current_user.otp_code.to_s)
    data = {:result =&gt; true} 
  end
end
respond_to do |format|
  format.json  { render :json =&gt; data} 
end
</code></pre>

<p>  end</p>

<p>```</p>

<p>``` haml new.html.haml</p>

<pre><code>= bootstrap_form_for @provider, id: @provider.id,  validate: true  do |f|
    .span{style: 'text-align: center'} 
      %h4= t('.provider_exp')
      %h5= t('.provider_exp1')
      #phone_details
        = f.label :mobile_phone, class: 'control-label', id: 'verify_phone_label'
        = f.default_tag :text_field, :verification_phone, placeholder: '05XX XXXXXXX', id: 'verification_phone' ,:class =&gt; "{mask:'(0569) 9999999'}", :alt=&gt; "(0569) 9999999'"     
        = button_to t('.send_code'), "#", :id=&gt; 'sendverification', :class=&gt; 'btn btn-medium btn-success'
        = f.label :error_mobile_label, class: 'control-label', id: 'error_mobile_label' 
      %hr
      #verification_details
        = f.label :info_label, class: 'control-label', id: 'verify_code_label' , style:"display:none"
        = f.default_tag :text_field, :verification_code, placeholder: 'XXXXXX', id: 'verification_code' ,:class =&gt; "{mask:'999999'}", :alt=&gt; "999999'" 
        = f.label :error_label, class: 'control-label', id: 'error_code_label' 
        = f.label :success_label, class: 'control-label', id: 'success_code_label' 
</code></pre>

<p><code>
</code> coffeescript providers.js.coffee</p>

<p>  $(&ldquo;#verification_code&rdquo;).bind &ldquo;keyup&rdquo;, &ndash;></p>

<pre><code>  if $(this).val().length is 6 #second clientside validation
    data = undefined
    $.ajax
      type: "POST"
      url: "/check_verification_code"
      data: "verification_code=" + $("#verification_code").val() 
      success: (data) -&gt;
        if data.result is true
          $("#provider_business_phone").val($("#verification_phone").val())
          clearInterval(interval)
          $("#error_code_label").hide()
          $("#success_code_label").show()            
          $("#verification_code").prop "disabled", true
          $("#provider_submit").prop "value", I18n.t "shared.navbar.pleasewait"            
          $("#providerform").submit() # provider gets mobile_verified inside
          return
        else
          $("#error_code_label").text I18n.t('shared.navbar.error_in_code').show()
        return
      error: (data) -&gt;
          $("#error_code_label").text  I18n.t('shared.navbar.problem_sending_request').show()  
          return
  else
    $("#error_code_label").hide()
    $("#success_code_label").hide()
    return
  return 

interval = undefined
$("#sendverification").click -&gt;
  if $("#verification_phone").val().length is 14 #second clientside vald(before svrside)
    time = 30000 #OTP default wait time
    seconds = Math.ceil(time / 1000)
    $(this).each -&gt;
      disabled_elem = $(this)
      $("#verification_phone").prop "disabled", true
      disabled_elem.prop "disabled", true 
      new_text =  I18n.t('shared.navbar.send_code_again') 
      disabled_elem.val new_text + " (" + seconds + ")"
      interval = setInterval(-&gt;
        disabled_elem.val new_text + " (" + --seconds + ")"
        if seconds is 0
          $("#verification_phone").prop "disabled", false
          disabled_elem.prop "disabled", false
          disabled_elem.val new_text
          clearInterval interval
        return
      , 1000)
      return
    $.ajax
      data: "verification_phone=" + $("#verification_phone").val()
      type: "get"
      url: "/sendverification"
      success: (data) -&gt;
        if data.result is true
          $("#verification_code").show()
          $("#verify_code_label").show()
          $("#error_mobile_label").hide()  
          $("#error_code_label").hide()
          $("#verification_code").val ''
          $("#verification_code").focus() 
          return
        else
          $("#error_mobile_label").text I18n.t('shared.navbar.problem_sending_sms').show() 
          return
      error: (data) -&gt;
          $("#error_mobile_label").text  I18n.t('shared.navbar.problem_sending_request').show()  
          return
  return false 
</code></pre>

<p>```</p>

<p>``` ruby providers_controller.rb
  def create</p>

<pre><code>...
if session[:mobile_verified] = true
  @provider.mobile_verified = true
  @provider.business_phone = validate_phone( params[:provider][:business_phone])
  session[:mobile_verified] = false
else
...
</code></pre>

<p>```</p>

<p>``` ruby user.rb
  require &ldquo;active_model_otp&rdquo;
  class User</p>

<pre><code>include Mongoid::Document
...
include ActiveModel::OneTimePassword 
...
has_one_time_password
...
field :email
field :otp_secret_key 
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
