<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jquery Validations | Caner's Ruby on rails blog]]></title>
  <link href="http://canercak.github.io/blog/categories/jquery-validations/atom.xml" rel="self"/>
  <link href="http://canercak.github.io/"/>
  <updated>2014-07-21T01:13:34+03:00</updated>
  <id>http://canercak.github.io/</id>
  <author>
    <name><![CDATA[Caner Cakmak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Full Login System Out of Omniauth-identity With Mongoid and Jquery Validations]]></title>
    <link href="http://canercak.github.io/blog/2014/02/09/full-login-system-out-of-omniauth-identity-with-mongoid-and-jquery-validations/"/>
    <updated>2014-02-09T11:31:32+02:00</updated>
    <id>http://canercak.github.io/blog/2014/02/09/full-login-system-out-of-omniauth-identity-with-mongoid-and-jquery-validations</id>
    <content type="html"><![CDATA[<p>I want to start this post with one definite sentence. Don’t use omniauth-identity! Why? Because it doesn’t cover the “details” of a login system. And for a login system details are absolutely necesssary. It does make the user register and sign-in but thats all. No forms, no password resets, no emails, no decent validations, etc. It’s really simple and that simplicity won’t help you. And the worst thing is it’s hard to customise. You have that initialiser file and you don’t understand what you do in there. There are also no resources other than Ryan’s Railscast and couple of blog posts. The reason I’m writing this blog post is because there may be people still wan’t to use it as I do. I’ve lost considerable amount of time dealing with it’s login fail bug, integrating it and making a decent login system out of it and now after all that time I don’t want to deal with login systems at all.</p>

<p>So we start with adding the gem</p>

<p>``` ruby Gemfile</p>

<pre><code>gem "omniauth"
gem 'omniauth-identity'
And we have this initialiser file also used in other omniauth providers. That line fixes the bug..
</code></pre>

<p>```</p>

<p>``` ruby config/initialisers/omniauth.rb</p>

<pre><code>OmniAuth.config.on_failure = Proc.new { |env|
  OmniAuth::FailureEndpoint.new(env).redirect_to_failure
}
end
</code></pre>

<p>```
Then we create the modal and yes it doesn’t directly integrate with your user model(or I didn’t lost time trying to do it). You will have a seperate mongoid collection and it will store identities</p>

<p>``` ruby models/identity.rb</p>

<pre><code>class Identity
  include Mongoid::Document
  include OmniAuth::Identity::Models::Mongoid

  field :email, type: String
  field :name, type: String
  field :password_digest, type: String
  field :username, type: String

  belongs_to :user
  validates_presence_of :name
  validate :uniqueness_of_email
  validates_format_of :email, :with =&gt; /^[-a-z0-9_+\.]+\@([-a-z0-9]+\.)+[a-z0-9]{2,4}$/i


  def uniqueness_of_email
    self.errors.add(:email, "email is already in use") unless User.find_by(email:email).nil?
  end

end
</code></pre>

<p>```</p>

<p>I have authentication file in models directory that also manages omniauth facebook so after saving the identity don’t forget to save the user too. I’m setting user’s provider as “identity”, since I only get name and email I had to set uid as username.</p>

<p>``` ruby models/concerns/user/authentication.rb</p>

<p>  def from_omniauth(auth)</p>

<pre><code>binding.pry

user = where(auth.slice(:provider, :uid)).first_or_initialize
return nil if user.new_record? &amp;&amp; !user.has_access?
  user.provider = auth.provider
  user.uid = auth.uid
  user.email = auth.email
  user.username = auth.uid
  user.set_fields_from_omniauth auth
  user.login_count = user.login_count+ 1
  user.save!
if user.login_count == 1
  UserMailer.welcome_email(self.first).deliver
end
user 
</code></pre>

<p>  end
```</p>

<p>Controller only has new method. Taken from Ryan’s railcast.</p>

<p>``` ruby controllers/identities_controller.rb
 class IdentitiesController &lt; ApplicationController</p>

<pre><code>def new
  @identity = env['omniauth.identity']
  @user =User.new
end
</code></pre>

<p>```</p>

<p>sessions controller as usual</p>

<p>``` ruby controllers/sessions_controller.rb</p>

<pre><code>class SessionsController &lt; ApplicationController

  skip_before_filter :require_login, except: [:destroy]

  def create
    if (user = User.from_omniauth env['omniauth.auth'])
      session[:user_id] = user.id.to_s
      redirect_to session.delete(:redirect_to) || new_quote_path
    else
      redirect_to root_path, flash: { error: t(APP_CONFIG.facebook.restricted_group_id ? 'flash.sessions.error.restricted' : 'flash.sessions.error.create') }
    end
  end

  def destroy
    session[:user_id] = nil
    redirect_to root_path
  end
  def failure

    redirect_to root_path, flash: { error: t(APP_CONFIG.facebook.restricted_group_id ? 'flash.sessions.error.restricted' : 'flash.sessions.error.create') }
  end
end
</code></pre>

<p>```</p>

<p>I use modals to show forms</p>

<p>``` haml views/pages/home.html.haml
  %big.inline-block.new-identity= link_to t(&lsquo;register_now&rsquo;), &lsquo;#new-identity&rsquo;, data: { toggle: &lsquo;modal&rsquo; }
  %big.inline-block.new-identity veya
  %big.inline-block.login-identity= link_to t(&lsquo;login_now&rsquo;), &lsquo;#login-identity&rsquo;, data: { toggle: &lsquo;modal&rsquo; }</p>

<p><code>
</code> haml views/shared/_modal_login_identity.html.haml</p>

<pre><code>#login-identity.modal.hide.fade{ tabindex: -1, role: 'dialog', 'aria-labelledby' =&gt; t('login_identity'), 'aria-hidden' =&gt; true }
  .modal-header
    %button.close{ type: 'button', data: { dismiss: 'modal' }, 'aria-hidden' =&gt; true } &amp;times;
    %h3= t('shared.navbar.login_identity')
  .modal-body
    = render 'identities/login'
  .modal-footer
    = link_to t('close'), '#', 'aria-hidden' =&gt; true, data: { dismiss: 'modal' }, class: 'btn'
</code></pre>

<p><code>
</code> haml views/shared/_modal_new_identity.html.haml</p>

<pre><code>#new-identity.modal.hide.fade{ tabindex: -1, role: 'dialog', 'aria-labelledby' =&gt; t('new_identity'), 'aria-hidden' =&gt; true }
  .modal-header
    %button.close{ type: 'button', data: { dismiss: 'modal' }, 'aria-hidden' =&gt; true } &amp;times;
    %h3= t('shared.navbar.new_identity')
  .modal-body
    =render 'identities/register'
  .modal-footer
    = link_to t('close'), '#', 'aria-hidden' =&gt; true, data: { dismiss: 'modal' }, class: 'btn'
</code></pre>

<p><code>
</code> ruby views/identities/_login.html.haml</p>

<pre><code>=form_tag('/auth/identity/callback',  :method =&gt; 'post', :id =&gt; 'actual-login-form') do
  = label_tag :login_error, t("shared.navbar.wrong_password"), class: 'control-label', id: 'error_code_label_login'
  .field
    = label_tag :auth_key,t('shared.navbar.email')
    = text_field_tag :auth_key, nil
  .field
    = label_tag :password, t('shared.navbar.password')
    = password_field_tag :password, nil
  .actions
    = submit_tag t('shared.navbar.login'), id: "login_submit", class: 'btn btn-primary', disable_with: t('helpers.disable_with')
  %br
    = link_to t('shared.navbar.forgot_password'), new_password_reset_path
- if flash[:error] == I18n.t("shared.navbar.wrong_password")
  :coffee
    $(document).on 'ready', -&gt;
      $("#login-identity").modal "show"
      $("#error_code_label_login").show()
      $("#password").focus()
</code></pre>

<p><code>
</code> ruby views/identities/_register.rb</p>

<pre><code>= form_tag "/auth/identity/register", id: 'signupForm' do
  - if @identity &amp;&amp; @identity.errors.any?
    .error_messages
      %h2
        = pluralize(@identity.errors.count, "error")
        prohibited this account from being saved:
      %ul
        - @identity.errors.full_messages.each do |msg|
          %li= msg
  .field
    = label_tag :name, t('shared.navbar.name')
    = text_field_tag :name, @identity.try(:name)
  .field
    = label_tag :email,t('shared.navbar.email')
    = text_field_tag :email, @identity.try(:email)
  .field
    = label_tag :password, t('shared.navbar.password')
    = password_field_tag :password
  .field
    = label_tag :password_confirmation,t('shared.navbar.password_again')
    = password_field_tag :password_confirmation
  = submit_tag t('shared.navbar.register'), class: 'btn btn-primary', disable_with: t('helpers.disable_with')
</code></pre>

<p>```
I use jquery validation which I love</p>

<p>``` coffeescript pages.js.coffee</p>

<pre><code>$(document).on 'ready', -&gt;

  $("#signupForm").validate
    errorClass: "error_class"
    validClass: "valid_class"
    rules:
      name: 
        required: true
      email:
        required: true
        email: true
        remote: "/users/check_email"
      password:
        required: true
        minlength: 5
      password_confirmation:
        required: true
        minlength: 5
        equalTo: "#password"
    messages:
      name: I18n.t "signup.name.required"
      password:
        required: I18n.t "signup.name"
        minlength: I18n.t "signup.password.minlength"
      password_confirmation:
        required: I18n.t "signup.password_confirmation.required"
        minlength: I18n.t "signup.password_confirmation.minlength"
        equalTo: I18n.t "signup.password_confirmation.equalTo"
      email:
        required: I18n.t "signup.email.required"
        email: I18n.t "signup.email.email"
        remote: I18n.t "signup.email.remote"

  $("#actual-login-form").validate
    errorClass: "error_class"
    validClass: "valid_class"
    rules:
      email:
        required: true
        email: true
      password:
        required: true
    messages:
      password:
        required: I18n.t "signup.name"
      email:
        required: I18n.t "signup.email.required"
        email: I18n.t "signup.email.email"
</code></pre>

<p><code>
</code> ruby controllers/users_controller/check_email.rb
  def check_email</p>

<pre><code>@user = User.find_by(email: params[:email])
respond_to do |format|
 format.json { render :json =&gt; !@user }
end
</code></pre>

<p>  end</p>

<p>```
My password reset codes</p>

<p>``` ruby controllers/password_resets_controller.rb</p>

<pre><code>class PasswordResetsController &lt; ApplicationController
  def new
  end

  def create
    user = User.find_by(email: params[:email])
    user.send_password_reset(user)
    redirect_to root_url, :notice =&gt; I18n.t("password_resets.email_sent")
  end

  def edit
    @user = User.find_by(password_reset_token: params[:id])
  end

  def update
    @user = User.find_by(password_reset_token: params[:id])
    if @user.password_reset_sent_at &lt; 2.hours.ago
      redirect_to new_password_reset_path, :alert =&gt; I18n.t("password_resets.expired")
    else
      @user.update_attributes(permitted_params.user)
      @identity = Identity.find_by email: @user.email
      @identity.password = @user.password
      @identity.password_confirmation = @user.password_confirmation
      if @identity.save
        redirect_to root_url, :notice =&gt; I18n.t("password_resets.password_has_been_reset")
      else
        redirect_to root_url, :notice =&gt; I18n.t("password_resets.error_in_password_reset")
      end
    end
  end
end
</code></pre>

<p><code>
</code> haml views/password_resets/new.html.haml</p>

<pre><code>= form_tag password_resets_path, :method =&gt; :post do
  .field
    = label_tag :email, t('shared.navbar.email')
    = text_field_tag :email, params[:email]
  = submit_tag t('shared.navbar.reset_password'),  class: 'btn btn-primary', disable_with: t('helpers.disable_with')
</code></pre>

<p><code>
</code> haml views/password_resets/edit.html.haml</p>

<pre><code>= form_for @user, :url =&gt; password_reset_path(params[:id]) do |f|
  - if @user.errors.any?
    .error_messages
      %h2 Form is invalid
      %ul
        - for message in @user.errors.full_messages
          %li= message
  .field
    = f.label :password
    = f.password_field :password
  .field
    = f.label :password_confirmation
    = f.password_field :password_confirmation
  .actions= f.submit "Update Password"
</code></pre>

<p>```
Mailers</p>

<p>``` ruby app/mailers/password_resets_mailer.rb
  def password_reset_email(user)</p>

<pre><code>@user = user
binding.pry
mail(to: user["email"], subject: t('user_mailer.pass_reset.subject'))
</code></pre>

<p>  end
```</p>

<p>and the actual mail which I’ve only paste the relevant part</p>

<p>``` haml app/views/mailers/password_reset.html.haml</p>

<pre><code>#href: "#{edit_password_reset_url(@user.password_reset_token)}"}=t(".pass_reset_link_button")
</code></pre>

<p>```
So it works. At least omniauth-identity has tests..I really could not do test-driven with it so I’ll add the tests soon..</p>
]]></content>
  </entry>
  
</feed>
